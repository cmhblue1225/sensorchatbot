<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Flash React Battle</title>
    
    <!-- í•„ìˆ˜ ìŠ¤í¬ë¦½íŠ¸ íƒœê·¸ë“¤ -->
    <!-- Socket.IO -->
    <script src="/socket.io/socket.io.js"></script>
    
    <!-- QR Code Generator -->
    <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js"></script>
    
    <!-- SessionSDK -->
    <script src="/js/SessionSDK.js"></script>
    
    <style>
        :root {
            --primary: #3b82f6;
            --secondary: #8b5cf6;
            --background: #0f172a;
            --text: #e2e8f0;
            --accent: #f472b6;
            --success: #22c55e;
            --error: #ef4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--background);
            color: var(--text);
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        .game-ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        .ui-panel {
            position: absolute;
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 16px;
            pointer-events: auto;
        }

        .score-panel {
            top: 20px;
            left: 20px;
            min-width: 150px;
        }

        .status-panel {
            top: 20px;
            right: 20px;
        }

        .session-panel {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 24px;
        }

        .session-info {
            margin-bottom: 20px;
        }

        .session-code {
            font-size: 24px;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 16px;
        }

        .qr-container {
            background: white;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .connection-status {
            margin-bottom: 20px;
        }

        .sensor-status {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--error);
            display: inline-block;
            margin-left: 8px;
        }

        .status-indicator.connected {
            background: var(--success);
        }

        .hidden {
            display: none;
        }

        .game-status {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.8);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
        }

        @keyframes flash {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .flash {
            animation: flash 0.5s infinite;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="game-ui">
        <div class="ui-panel score-panel">
            <div id="scoreValue">ì ìˆ˜: 0</div>
            <div id="roundInfo">ë¼ìš´ë“œ: 0/10</div>
        </div>
        
        <div class="ui-panel status-panel">
            <div class="status-item">
                ì„œë²„: <div id="serverStatus" class="status-indicator"></div>
            </div>
            <div class="status-item">
                ì„¼ì„œ: <div id="sensorStatus" class="status-indicator"></div>
            </div>
        </div>

        <div id="sessionPanel" class="ui-panel session-panel">
            <div class="session-info">
                <h3>ê²Œì„ ì„¸ì…˜</h3>
                <div class="session-code">
                    <span>ì„¸ì…˜ ì½”ë“œ: </span>
                    <strong id="session-code-display">-</strong>
                </div>
                <div class="qr-container" id="qrContainer">
                    QR ì½”ë“œ ìƒì„± ì¤‘...
                </div>
            </div>
            <div class="connection-status">
                <div class="sensor-status">
                    <span>ğŸ“± ì„¼ì„œ:</span>
                    <span class="status-indicator waiting" id="sensor-status">ëŒ€ê¸°ì¤‘</span>
                </div>
            </div>
            <button id="start-game-btn" disabled>ê²Œì„ ì‹œì‘</button>
        </div>

        <div id="gameStatus" class="game-status">
            ê²Œì„ ì¤€ë¹„ ì¤‘...
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
    <script src="/js/SessionSDK.js"></script>

    <script>
        class FlashReactBattle {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.elements = {
                    canvas: document.getElementById('gameCanvas'),
                    serverStatus: document.getElementById('serverStatus'),
                    sensorStatus: document.getElementById('sensorStatus'),
                    sessionCode: document.getElementById('session-code-display'),
                    qrContainer: document.getElementById('qrContainer'),
                    sessionPanel: document.getElementById('sessionPanel'),
                    scoreValue: document.getElementById('scoreValue'),
                    roundInfo: document.getElementById('roundInfo'),
                    gameStatus: document.getElementById('gameStatus'),
                    startBtn: document.getElementById('start-game-btn'),
                    statusIndicator: document.getElementById('sensor-status')
                };

                this.state = {
                    connected: false,
                    sensorConnected: false,
                    playing: false,
                    paused: false,
                    round: 0,
                    score: 0,
                    sessionCode: null
                };

                this.sensorData = {
                    tilt: { x: 0, y: 0 },
                    acceleration: { x: 0, y: 0, z: 0 },
                    rotation: 0
                };

                this.config = {
                    maxRounds: 10,
                    targetSize: 50,
                    targetSpeed: 5
                };

                this.player = {
                    health: 100,
                    energy: 100,
                    aimOffset: { x: 0, y: 0 }
                };

                this.target = {
                    x: 0,
                    y: 0,
                    visible: false,
                    timestamp: 0
                };

                this.initSDK();
                this.setupEventListeners();
                this.resizeCanvas();
                this.gameLoop();
            }

            initSDK() {
                this.sdk = new SessionSDK({
                    gameId: 'flash-react-battle',
                    gameType: 'multi',
                    debug: true
                });

                this.setupSDKEvents();
            }

            setupSDKEvents() {
                this.sdk.on('connected', async () => {
                    try {
                        this.state.connected = true;
                        this.updateServerStatus(true);
                        this.updateGameStatus('ì„œë²„ ì—°ê²°ë¨ - ì„¸ì…˜ ìƒì„± ì¤‘...');
                        await this.createGameSession();
                    } catch (error) {
                        console.error('Connected event handler error:', error);
                        this.updateGameStatus('ì—°ê²° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                    }
                });

                this.sdk.on('session-created', (event) => {
                    try {
                        const session = event.detail || event;
                        if (!session || !session.sessionCode) {
                            throw new Error('Invalid session data received');
                        }
                        this.state.sessionCode = session.sessionCode;
                        this.displaySessionInfo(session);
                        this.updateGameStatus('ì„¼ì„œ ì—°ê²° ëŒ€ê¸° ì¤‘...');
                    } catch (error) {
                        console.error('Session created event handler error:', error);
                        this.updateGameStatus('ì„¸ì…˜ ì •ë³´ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                    }
                });

                this.sdk.on('sensor-connected', (event) => {
                    try {
                        const data = event.detail || event;
                        this.state.sensorConnected = true;
                        this.updateSensorStatus(true);
                        this.hideSessionPanel();
                        this.startGame();
                    } catch (error) {
                        console.error('Sensor connected event handler error:', error);
                        this.updateGameStatus('ì„¼ì„œ ì—°ê²° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                    }
                });

                this.sdk.on('sensor-data', (event) => {
                    try {
                        const data = event.detail || event;
                        this.processSensorData(data);
                    } catch (error) {
                        console.error('Sensor data event handler error:', error);
                        // ì„¼ì„œ ë°ì´í„° ì˜¤ë¥˜ëŠ” ê²Œì„ì„ ì¤‘ë‹¨í•˜ì§€ ì•Šê³  ë¡œê·¸ë§Œ ì¶œë ¥
                    }
                });

                // ì¶”ê°€ ì—ëŸ¬ ì´ë²¤íŠ¸ ì²˜ë¦¬
                this.sdk.on('connection-error', (event) => {
                    const error = event.detail || event;
                    console.error('Connection error:', error);
                    this.updateGameStatus('ì„œë²„ ì—°ê²° ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                    this.updateServerStatus(false);
                });

                this.sdk.on('session-error', (event) => {
                    const error = event.detail || event;
                    console.error('Session error:', error);
                    this.updateGameStatus('ì„¸ì…˜ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                });
            }

            async createGameSession() {
                try {
                    await this.sdk.createSession();
                } catch (error) {
                    console.error('ì„¸ì…˜ ìƒì„± ì‹¤íŒ¨:', error);
                    this.updateGameStatus('ì„¸ì…˜ ìƒì„± ì‹¤íŒ¨. ì¬ì‹œë„ ì¤‘...');
                    
                    // ì¬ì‹œë„ íšŸìˆ˜ ì œí•œ
                    if (!this.retryCount) this.retryCount = 0;
                    this.retryCount++;
                    
                    if (this.retryCount < 5) {
                        setTimeout(() => this.createGameSession(), 3000 * this.retryCount);
                    } else {
                        this.updateGameStatus('ì„¸ì…˜ ìƒì„±ì— ê³„ì† ì‹¤íŒ¨í•©ë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ì£¼ì„¸ìš”.');
                    }
                }
            }

            async displaySessionInfo(session) {
                this.elements.sessionCode.textContent = `ì„¸ì…˜ ì½”ë“œ: ${session.sessionCode}`;
                
                const sensorUrl = `${window.location.origin}/sensor.html?session=${session.sessionCode}`;
                try {
                    // QRCodeGenerator í´ë˜ìŠ¤ ì‚¬ìš© (SessionSDKì—ì„œ ì œê³µ)
                    const qrElement = await QRCodeGenerator.generateElement(sensorUrl, 200);
                    this.elements.qrContainer.innerHTML = '';
                    this.elements.qrContainer.appendChild(qrElement);
                } catch (error) {
                    console.error('QR ì½”ë“œ ìƒì„± ì‹¤íŒ¨, í´ë°± ì²˜ë¦¬:', error);
                    // í´ë°±: í…ìŠ¤íŠ¸ ë§í¬ í‘œì‹œ
                    this.elements.qrContainer.innerHTML = `
                        <div class="qr-fallback">
                            <p>QR ì½”ë“œë¥¼ ìŠ¤ìº”í•  ìˆ˜ ì—†ëŠ” ê²½ìš°:</p>
                            <a href="${sensorUrl}" target="_blank">${sensorUrl}</a>
                        </div>
                    `;
                }
            }

            processSensorData(data) {
                // ì„¼ì„œ ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬ ê°•í™”
                if (!data || !data.data) {
                    console.warn('Invalid sensor data received:', data);
                    return;
                }
                
                const sensorData = data.data;
                
                // ì˜¤ë¦¬ì—”í…Œì´ì…˜ ë°ì´í„° ì²˜ë¦¬ (ì•ˆì „í•œ ì ‘ê·¼)
                if (sensorData.orientation) {
                    const orientation = sensorData.orientation;
                    this.sensorData.tilt.x = typeof orientation.beta === 'number' ? orientation.beta : 0;
                    this.sensorData.tilt.y = typeof orientation.gamma === 'number' ? orientation.gamma : 0;
                    this.sensorData.rotation = typeof orientation.alpha === 'number' ? orientation.alpha : 0;
                } else {
                    // ì˜¤ë¦¬ì—”í…Œì´ì…˜ ë°ì´í„°ê°€ ì—†ì„ ë•Œ ê¸°ë³¸ê°’ ìœ ì§€
                    console.warn('No orientation data in sensor input');
                }
                
                // ê°€ì†ë„ ë°ì´í„° ì²˜ë¦¬ (ì•ˆì „í•œ ì ‘ê·¼)
                if (sensorData.acceleration && typeof sensorData.acceleration === 'object') {
                    const acc = sensorData.acceleration;
                    this.sensorData.acceleration = {
                        x: typeof acc.x === 'number' ? acc.x : 0,
                        y: typeof acc.y === 'number' ? acc.y : 0,
                        z: typeof acc.z === 'number' ? acc.z : 0
                    };
                    
                    // í”ë“¤ê¸° ê°ì§€ (ê²Œì„ì´ ì‹¤í–‰ ì¤‘ì¼ ë•Œë§Œ)
                    if (this.state.playing && !this.state.paused) {
                        this.checkShake();
                    }
                } else {
                    console.warn('No acceleration data in sensor input');
                }
                
                // ê²Œì„ ë¡œì§ ì ìš© (ê²Œì„ì´ ì‹¤í–‰ ì¤‘ì´ê³  ì¼ì‹œì •ì§€ê°€ ì•„ë‹ ë•Œë§Œ)
                if (this.state.playing && !this.state.paused) {
                    try {
                        this.applyMotion();
                    } catch (error) {
                        console.error('Error in applyMotion:', error);
                    }
                }
            }

            checkShake() {
                const threshold = 15;
                const acc = this.sensorData.acceleration;
                const magnitude = Math.sqrt(acc.x * acc.x + acc.y * acc.y + acc.z * acc.z);
                
                if (magnitude > threshold && this.target.visible) {
                    this.hitTarget();
                }
            }

            // ëˆ„ë½ëœ applyMotion ë©”ì„œë“œ êµ¬í˜„
            applyMotion() {
                // ê¸°ê¸° ê¸°ìš¸ê¸°ë¥¼ ì´ìš©í•œ ì¡°ì¤€ ì‹œìŠ¤í…œ (ë¯¸ì„¸í•œ ë³´ì •)
                const sensitivity = 0.5;
                const tiltX = Math.max(-1, Math.min(1, this.sensorData.tilt.y / 30)); // gamma (ì¢Œìš°)
                const tiltY = Math.max(-1, Math.min(1, this.sensorData.tilt.x / 30)); // beta (ì•ë’¤)
                
                // ì¡°ì¤€ì  ë¯¸ì„¸ ì¡°ì • (ê²Œì„ ì¤‘ ê¸°ê¸°ë¥¼ ì•½ê°„ ê¸°ìš¸ì—¬ì„œ ì¡°ì¤€ ê°€ëŠ¥)
                this.player.aimOffset.x += tiltX * sensitivity;
                this.player.aimOffset.y += tiltY * sensitivity;
                
                // ì¡°ì¤€ ì˜¤í”„ì…‹ ì œí•œ
                this.player.aimOffset.x = Math.max(-20, Math.min(20, this.player.aimOffset.x));
                this.player.aimOffset.y = Math.max(-20, Math.min(20, this.player.aimOffset.y));
            }

            // ì„¼ì„œ ìƒíƒœ ì—…ë°ì´íŠ¸ ë©”ì„œë“œ
            updateSensorStatus(connected) {
                if (connected) {
                    this.elements.statusIndicator.className = 'status-indicator connected';
                    this.elements.statusIndicator.style.background = 'var(--success)';
                } else {
                    this.elements.statusIndicator.className = 'status-indicator disconnected';
                    this.elements.statusIndicator.style.background = 'var(--error)';
                }
            }

            // ì„¸ì…˜ íŒ¨ë„ ìˆ¨ê¸°ê¸° ë©”ì„œë“œ
            hideSessionPanel() {
                if (this.elements.sessionPanel) {
                    this.elements.sessionPanel.style.display = 'none';
                }
            }

            // ì„œë²„ ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸
            updateServerStatus(connected) {
                console.log(`ì„œë²„ ì—°ê²° ìƒíƒœ: ${connected ? 'ì—°ê²°ë¨' : 'ì—°ê²° ì•ˆë¨'}`);
            }

            // ê²Œì„ ìƒíƒœ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸
            updateGameStatus(message) {
                console.log(`ê²Œì„ ìƒíƒœ: ${message}`);
                // í•„ìš”ì‹œ UI ìš”ì†Œì— ë©”ì‹œì§€ í‘œì‹œ
            }

            hitTarget() {
                const reactionTime = Date.now() - this.target.timestamp;
                const maxScore = 1000;
                const minReactionTime = 200;
                const maxReactionTime = 1000;
                
                let score = Math.max(0, Math.floor(
                    maxScore * (1 - (reactionTime - minReactionTime) / (maxReactionTime - minReactionTime))
                ));

                this.state.score += score;
                this.target.visible = false;
                this.updateScore();
                this.nextRound();
            }

            startGame() {
                this.state.playing = true;
                this.state.round = 0;
                this.state.score = 0;
                this.updateScore();
                this.nextRound();
            }

            nextRound() {
                this.state.round++;
                if (this.state.round > this.config.maxRounds) {
                    this.endGame();
                    return;
                }

                this.elements.roundInfo.textContent = `ë¼ìš´ë“œ: ${this.state.round}/${this.config.maxRounds}`;
                setTimeout(() => this.showTarget(), Math.random() * 2000 + 1000);
            }

            showTarget() {
                if (!this.state.playing) return;
                
                this.target.x = Math.random() * (this.canvas.width - this.config.targetSize);
                this.target.y = Math.random() * (this.canvas.height - this.config.targetSize);
                this.target.visible = true;
                this.target.timestamp = Date.now();
            }

            endGame() {
                this.state.playing = false;
                this.updateGameStatus(`ê²Œì„ ì¢…ë£Œ! ìµœì¢… ì ìˆ˜: ${this.state.score}`);
                setTimeout(() => {
                    if (confirm('ë‹¤ì‹œ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                        this.startGame();
                    }
                }, 1000);
            }

            updateScore() {
                this.elements.scoreValue.textContent = `ì ìˆ˜: ${this.state.score}`;
            }

            updateGameStatus(message) {
                this.elements.gameStatus.textContent = message;
            }

            updateServerStatus(connected) {
                this.elements.serverStatus.classList.toggle('connected', connected);
            }

            updateSensorStatus(connected) {
                this.elements.sensorStatus.classList.toggle('connected', connected);
            }

            hideSessionPanel() {
                this.elements.sessionPanel.classList.add('hidden');
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            gameLoop() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                if (this.state.playing && this.target.visible) {
                    this.ctx.fillStyle = '#f472b6';
                    this.ctx.beginPath();
                    this.ctx.arc(
                        this.target.x + this.config.targetSize/2,
                        this.target.y + this.config.targetSize/2,
                        this.config.targetSize/2,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.fill();
                }

                requestAnimationFrame(() => this.gameLoop());
            }

            setupEventListeners() {
                window.addEventListener('resize', () => this.resizeCanvas());
            }
        }

        // ê²Œì„ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
        window.addEventListener('load', () => {
            const game = new FlashReactBattle();
        });
    </script>
</body>
</html>