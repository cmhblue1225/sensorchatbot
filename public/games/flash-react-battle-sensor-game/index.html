<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Flash React Battle</title>
    
    <!-- ÌïÑÏàò Ïä§ÌÅ¨Î¶ΩÌä∏ ÌÉúÍ∑∏Îì§ -->
    <!-- Socket.IO -->
    <script src="/socket.io/socket.io.js"></script>
    
    <!-- QR Code Generator -->
    <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js"></script>
    
    <!-- SessionSDK -->
    <script src="/js/SessionSDK.js"></script>
    
    <style>
        :root {
            --primary: #3b82f6;
            --secondary: #8b5cf6;
            --background: #0f172a;
            --text: #e2e8f0;
            --accent: #f472b6;
            --success: #22c55e;
            --error: #ef4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--background);
            color: var(--text);
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        .game-ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        .ui-panel {
            position: absolute;
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 16px;
            pointer-events: auto;
        }

        .score-panel {
            top: 20px;
            left: 20px;
            min-width: 150px;
        }

        .status-panel {
            top: 20px;
            right: 20px;
        }

        .session-panel {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 24px;
        }

        .session-info {
            margin-bottom: 20px;
        }

        .session-code {
            font-size: 24px;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 16px;
        }

        .qr-container {
            background: white;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .connection-status {
            margin-bottom: 20px;
        }

        .sensor-status {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--error);
            display: inline-block;
            margin-left: 8px;
        }

        .status-indicator.connected {
            background: var(--success);
        }

        .hidden {
            display: none;
        }

        .game-status {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.8);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
        }

        @keyframes flash {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .flash {
            animation: flash 0.5s infinite;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="game-ui">
        <div class="ui-panel score-panel">
            <div id="scoreValue">Ï†êÏàò: 0</div>
            <div id="roundInfo">ÎùºÏö¥Îìú: 0/10</div>
        </div>
        
        <div class="ui-panel status-panel">
            <div class="status-item">
                ÏÑúÎ≤Ñ: <div id="serverStatus" class="status-indicator"></div>
            </div>
            <div class="status-item">
                ÏÑºÏÑú: <div id="sensorStatus" class="status-indicator"></div>
            </div>
        </div>

        <div id="sessionPanel" class="ui-panel session-panel">
            <div class="session-info">
                <h3>Í≤åÏûÑ ÏÑ∏ÏÖò</h3>
                <div class="session-code">
                    <span>ÏÑ∏ÏÖò ÏΩîÎìú: </span>
                    <strong id="session-code-display">-</strong>
                </div>
                <div class="qr-container" id="qrContainer">
                    QR ÏΩîÎìú ÏÉùÏÑ± Ï§ë...
                </div>
            </div>
            <div class="connection-status">
                <div class="sensor-status">
                    <span>üì± ÏÑºÏÑú:</span>
                    <span class="status-indicator waiting" id="sensor-status">ÎåÄÍ∏∞Ï§ë</span>
                </div>
            </div>
            <button id="start-game-btn" disabled>Í≤åÏûÑ ÏãúÏûë</button>
        </div>

        <div id="gameStatus" class="game-status">
            Í≤åÏûÑ Ï§ÄÎπÑ Ï§ë...
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
    <script src="/js/SessionSDK.js"></script>

    <script>
        class FlashReactBattle {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.elements = {
                    canvas: document.getElementById('gameCanvas'),
                    serverStatus: document.getElementById('serverStatus'),
                    sensorStatus: document.getElementById('sensorStatus'),
                    sessionCode: document.getElementById('session-code-display'),
                    qrContainer: document.getElementById('qrContainer'),
                    sessionPanel: document.getElementById('sessionPanel'),
                    scoreValue: document.getElementById('scoreValue'),
                    roundInfo: document.getElementById('roundInfo'),
                    gameStatus: document.getElementById('gameStatus'),
                    startBtn: document.getElementById('start-game-btn'),
                    statusIndicator: document.getElementById('sensor-status')
                };

                this.state = {
                    connected: false,
                    sensorConnected: false,
                    playing: false,
                    paused: false,
                    round: 0,
                    score: 0,
                    sessionCode: null
                };

                this.sensorData = {
                    tilt: { x: 0, y: 0 },
                    acceleration: { x: 0, y: 0, z: 0 },
                    rotation: 0
                };

                this.config = {
                    maxRounds: 10,
                    targetSize: 50,
                    targetSpeed: 5
                };

                this.player = {
                    health: 100,
                    energy: 100,
                    aimOffset: { x: 0, y: 0 }
                };

                this.target = {
                    x: 0,
                    y: 0,
                    visible: false,
                    timestamp: 0
                };

                this.initSDK();
                this.setupEventListeners();
                this.resizeCanvas();
                this.gameLoop();
            }

            initSDK() {
                this.sdk = new SessionSDK({
                    gameId: 'flash-react-battle',
                    gameType: 'multi',
                    debug: true
                });

                this.setupSDKEvents();
            }

            setupSDKEvents() {
                this.sdk.on('connected', async () => {
                    try {
                        this.state.connected = true;
                        this.updateServerStatus(true);
                        this.updateGameStatus('ÏÑúÎ≤Ñ Ïó∞Í≤∞Îê® - ÏÑ∏ÏÖò ÏÉùÏÑ± Ï§ë...');
                        await this.createGameSession();
                    } catch (error) {
                        console.error('Connected event handler error:', error);
                        this.updateGameStatus('Ïó∞Í≤∞ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
                    }
                });

                this.sdk.on('session-created', (event) => {
                    try {
                        const session = event.detail || event;
                        if (!session || !session.sessionCode) {
                            throw new Error('Invalid session data received');
                        }
                        this.state.sessionCode = session.sessionCode;
                        this.displaySessionInfo(session);
                        this.updateGameStatus('ÏÑºÏÑú Ïó∞Í≤∞ ÎåÄÍ∏∞ Ï§ë...');
                    } catch (error) {
                        console.error('Session created event handler error:', error);
                        this.updateGameStatus('ÏÑ∏ÏÖò Ï†ïÎ≥¥ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
                    }
                });

                this.sdk.on('sensor-connected', (event) => {
                    try {
                        const data = event.detail || event;
                        this.state.sensorConnected = true;
                        this.updateSensorStatus(true);
                        this.hideSessionPanel();
                        this.startGame();
                    } catch (error) {
                        console.error('Sensor connected event handler error:', error);
                        this.updateGameStatus('ÏÑºÏÑú Ïó∞Í≤∞ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
                    }
                });

                this.sdk.on('sensor-data', (event) => {
                    try {
                        const data = event.detail || event;
                        this.processSensorData(data);
                    } catch (error) {
                        console.error('Sensor data event handler error:', error);
                        // ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ Ïò§Î•òÎäî Í≤åÏûÑÏùÑ Ï§ëÎã®ÌïòÏßÄ ÏïäÍ≥† Î°úÍ∑∏Îßå Ï∂úÎ†•
                    }
                });

                // Ï∂îÍ∞Ä ÏóêÎü¨ Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
                this.sdk.on('connection-error', (event) => {
                    const error = event.detail || event;
                    console.error('Connection error:', error);
                    this.updateGameStatus('ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
                    this.updateServerStatus(false);
                });

                this.sdk.on('session-error', (event) => {
                    const error = event.detail || event;
                    console.error('Session error:', error);
                    this.updateGameStatus('ÏÑ∏ÏÖò Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
                });
            }

            async createGameSession() {
                try {
                    await this.sdk.createSession();
                } catch (error) {
                    console.error('ÏÑ∏ÏÖò ÏÉùÏÑ± Ïã§Ìå®:', error);
                    this.updateGameStatus('ÏÑ∏ÏÖò ÏÉùÏÑ± Ïã§Ìå®. Ïû¨ÏãúÎèÑ Ï§ë...');
                    
                    // Ïû¨ÏãúÎèÑ ÌöüÏàò Ï†úÌïú
                    if (!this.retryCount) this.retryCount = 0;
                    this.retryCount++;
                    
                    if (this.retryCount < 5) {
                        setTimeout(() => this.createGameSession(), 3000 * this.retryCount);
                    } else {
                        this.updateGameStatus('ÏÑ∏ÏÖò ÏÉùÏÑ±Ïóê Í≥ÑÏÜç Ïã§Ìå®Ìï©ÎãàÎã§. ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ®Ìï¥Ï£ºÏÑ∏Ïöî.');
                    }
                }
            }

            async displaySessionInfo(session) {
                this.elements.sessionCode.textContent = `ÏÑ∏ÏÖò ÏΩîÎìú: ${session.sessionCode}`;
                
                const sensorUrl = `${window.location.origin}/sensor.html?session=${session.sessionCode}`;
                try {
                    // QRCodeGenerator ÌÅ¥ÎûòÏä§ ÏÇ¨Ïö© (SessionSDKÏóêÏÑú Ï†úÍ≥µ)
                    const qrElement = await QRCodeGenerator.generateElement(sensorUrl, 200);
                    this.elements.qrContainer.innerHTML = '';
                    this.elements.qrContainer.appendChild(qrElement);
                } catch (error) {
                    console.error('QR ÏΩîÎìú ÏÉùÏÑ± Ïã§Ìå®, Ìè¥Î∞± Ï≤òÎ¶¨:', error);
                    // Ìè¥Î∞±: ÌÖçÏä§Ìä∏ ÎßÅÌÅ¨ ÌëúÏãú
                    this.elements.qrContainer.innerHTML = `
                        <div class="qr-fallback">
                            <p>QR ÏΩîÎìúÎ•º Ïä§Ï∫îÌï† Ïàò ÏóÜÎäî Í≤ΩÏö∞:</p>
                            <a href="${sensorUrl}" target="_blank">${sensorUrl}</a>
                        </div>
                    `;
                }
            }

            processSensorData(data) {
                // ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Í∞ïÌôî
                if (!data || !data.data) {
                    console.warn('Invalid sensor data received:', data);
                    return;
                }
                
                const sensorData = data.data;
                
                // Ïò§Î¶¨ÏóîÌÖåÏù¥ÏÖò Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ (ÏïàÏ†ÑÌïú Ï†ëÍ∑º)
                if (sensorData.orientation) {
                    const orientation = sensorData.orientation;
                    this.sensorData.tilt.x = typeof orientation.beta === 'number' ? orientation.beta : 0;
                    this.sensorData.tilt.y = typeof orientation.gamma === 'number' ? orientation.gamma : 0;
                    this.sensorData.rotation = typeof orientation.alpha === 'number' ? orientation.alpha : 0;
                } else {
                    // Ïò§Î¶¨ÏóîÌÖåÏù¥ÏÖò Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏùÑ Îïå Í∏∞Î≥∏Í∞í Ïú†ÏßÄ
                    console.warn('No orientation data in sensor input');
                }
                
                // Í∞ÄÏÜçÎèÑ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ (ÏïàÏ†ÑÌïú Ï†ëÍ∑º)
                if (sensorData.acceleration && typeof sensorData.acceleration === 'object') {
                    const acc = sensorData.acceleration;
                    this.sensorData.acceleration = {
                        x: typeof acc.x === 'number' ? acc.x : 0,
                        y: typeof acc.y === 'number' ? acc.y : 0,
                        z: typeof acc.z === 'number' ? acc.z : 0
                    };
                    
                    // ÌùîÎì§Í∏∞ Í∞êÏßÄ (Í≤åÏûÑÏù¥ Ïã§Ìñâ Ï§ëÏùº ÎïåÎßå)
                    if (this.state.playing && !this.state.paused) {
                        this.checkShake();
                    }
                } else {
                    console.warn('No acceleration data in sensor input');
                }
                
                // Í≤åÏûÑ Î°úÏßÅ Ï†ÅÏö© (Í≤åÏûÑÏù¥ Ïã§Ìñâ Ï§ëÏù¥Í≥† ÏùºÏãúÏ†ïÏßÄÍ∞Ä ÏïÑÎãê ÎïåÎßå)
                if (this.state.playing && !this.state.paused) {
                    try {
                        this.applyMotion();
                    } catch (error) {
                        console.error('Error in applyMotion:', error);
                    }
                }
            }

            checkShake() {
                const threshold = 15;
                const acc = this.sensorData.acceleration;
                const magnitude = Math.sqrt(acc.x * acc.x + acc.y * acc.y + acc.z * acc.z);
                
                if (magnitude > threshold && this.target.visible) {
                    this.hitTarget();
                }
            }

            // ÎàÑÎùΩÎêú applyMotion Î©îÏÑúÎìú Íµ¨ÌòÑ
            applyMotion() {
                // Í∏∞Í∏∞ Í∏∞Ïö∏Í∏∞Î•º Ïù¥Ïö©Ìïú Ï°∞Ï§Ä ÏãúÏä§ÌÖú (ÎØ∏ÏÑ∏Ìïú Î≥¥Ï†ï)
                const sensitivity = 0.5;
                const tiltX = Math.max(-1, Math.min(1, this.sensorData.tilt.y / 30)); // gamma (Ï¢åÏö∞)
                const tiltY = Math.max(-1, Math.min(1, this.sensorData.tilt.x / 30)); // beta (ÏïûÎí§)
                
                // Ï°∞Ï§ÄÏ†ê ÎØ∏ÏÑ∏ Ï°∞Ï†ï (Í≤åÏûÑ Ï§ë Í∏∞Í∏∞Î•º ÏïΩÍ∞Ñ Í∏∞Ïö∏Ïó¨ÏÑú Ï°∞Ï§Ä Í∞ÄÎä•)
                this.player.aimOffset.x += tiltX * sensitivity;
                this.player.aimOffset.y += tiltY * sensitivity;
                
                // Ï°∞Ï§Ä Ïò§ÌîÑÏÖã Ï†úÌïú
                this.player.aimOffset.x = Math.max(-20, Math.min(20, this.player.aimOffset.x));
                this.player.aimOffset.y = Math.max(-20, Math.min(20, this.player.aimOffset.y));
            }

            // ÏÑºÏÑú ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ Î©îÏÑúÎìú
            updateSensorStatus(connected) {
                if (connected) {
                    this.elements.statusIndicator.className = 'status-indicator connected';
                    this.elements.statusIndicator.style.background = 'var(--success)';
                } else {
                    this.elements.statusIndicator.className = 'status-indicator disconnected';
                    this.elements.statusIndicator.style.background = 'var(--error)';
                }
            }

            // ÏÑ∏ÏÖò Ìå®ÎÑê Ïà®Í∏∞Í∏∞ Î©îÏÑúÎìú
            hideSessionPanel() {
                if (this.elements.sessionPanel) {
                    this.elements.sessionPanel.style.display = 'none';
                }
            }

            // ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
            updateServerStatus(connected) {
                console.log(`ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÉÅÌÉú: ${connected ? 'Ïó∞Í≤∞Îê®' : 'Ïó∞Í≤∞ ÏïàÎê®'}`);
            }

            // Í≤åÏûÑ ÏÉÅÌÉú Î©îÏãúÏßÄ ÏóÖÎç∞Ïù¥Ìä∏
            updateGameStatus(message) {
                console.log(`Í≤åÏûÑ ÏÉÅÌÉú: ${message}`);
                // ÌïÑÏöîÏãú UI ÏöîÏÜåÏóê Î©îÏãúÏßÄ ÌëúÏãú
            }

            hitTarget() {
                const reactionTime = Date.now() - this.target.timestamp;
                const maxScore = 1000;
                const minReactionTime = 200;
                const maxReactionTime = 1000;
                
                let score = Math.max(0, Math.floor(
                    maxScore * (1 - (reactionTime - minReactionTime) / (maxReactionTime - minReactionTime))
                ));

                this.state.score += score;
                this.target.visible = false;
                this.updateScore();
                this.nextRound();
            }

            startGame() {
                this.state.playing = true;
                this.state.round = 0;
                this.state.score = 0;
                this.updateScore();
                this.nextRound();
            }

            nextRound() {
                this.state.round++;
                if (this.state.round > this.config.maxRounds) {
                    this.endGame();
                    return;
                }

                this.elements.roundInfo.textContent = `ÎùºÏö¥Îìú: ${this.state.round}/${this.config.maxRounds}`;
                setTimeout(() => this.showTarget(), Math.random() * 2000 + 1000);
            }

            showTarget() {
                if (!this.state.playing) return;
                
                this.target.x = Math.random() * (this.canvas.width - this.config.targetSize);
                this.target.y = Math.random() * (this.canvas.height - this.config.targetSize);
                this.target.visible = true;
                this.target.timestamp = Date.now();
            }

            endGame() {
                this.state.playing = false;
                this.updateGameStatus(`Í≤åÏûÑ Ï¢ÖÎ£å! ÏµúÏ¢Ö Ï†êÏàò: ${this.state.score}`);
                setTimeout(() => {
                    if (confirm('Îã§Ïãú ÏãúÏûëÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
                        this.startGame();
                    }
                }, 1000);
            }

            updateScore() {
                this.elements.scoreValue.textContent = `Ï†êÏàò: ${this.state.score}`;
            }

            updateGameStatus(message) {
                this.elements.gameStatus.textContent = message;
            }

            updateServerStatus(connected) {
                this.elements.serverStatus.classList.toggle('connected', connected);
            }

            updateSensorStatus(connected) {
                this.elements.sensorStatus.classList.toggle('connected', connected);
            }

            hideSessionPanel() {
                this.elements.sessionPanel.classList.add('hidden');
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            gameLoop() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                if (this.state.playing && this.target.visible) {
                    this.ctx.fillStyle = '#f472b6';
                    this.ctx.beginPath();
                    this.ctx.arc(
                        this.target.x + this.config.targetSize/2,
                        this.target.y + this.config.targetSize/2,
                        this.config.targetSize/2,
                        0,
                        Math.PI * 2
                    );
                    this.ctx.fill();
                }

                requestAnimationFrame(() => this.gameLoop());
            }

            setupEventListeners() {
                window.addEventListener('resize', () => this.resizeCanvas());
            }
        }

        // Í≤åÏûÑ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
        window.addEventListener('load', () => {
            const game = new FlashReactBattle();
        });
    </script>
</body>
</html>